package fib_Module5;

import java.util.Arrays;

public class FibSequencer 
{
	// store the Fibonacci Sequence here.  
	private double[] fibElements;
	private int sizeOfSequence;
	
	// when we generate fibonacci sequence with recursive method, 
	// we will track the number of iterations it was called by this variable.
	private int recursiveCounter;
	
	// values for sequencing in both algorithms
	private double previousValue;
	private double currentValue;
	
	// variables to keep track of start and end times
	private long startTime;
	private long endTime;
	private long durationTime;
	
	// basic enumeration to define which type of algorithm i will use to generate the fibonacci sequence
	public enum AlgorithmType
	{
		ITERATION,
		RECURSIVE,
		ITERATION_OPT,
		RECURSIVE_OPT
	}
	
	// store the way we want to generate fibnonacci sequence
	private AlgorithmType sequenceBy;
	
	// default constructor
	FibSequencer()
	{
		sizeOfSequence = recursiveCounter = 10;
		fibElements = new double[sizeOfSequence];
		sequenceBy = AlgorithmType.ITERATION;
		fibElements[0] = previousValue = 0.0;
		fibElements[1] = currentValue = 1.0;
		startTime = endTime = durationTime = 0;
	}
	
	FibSequencer(int timesToIterate, AlgorithmType wayToIterate)
	{
		sizeOfSequence = recursiveCounter = timesToIterate;
		fibElements = new double[sizeOfSequence];
		sequenceBy = wayToIterate;
		previousValue = 0.0;
		fibElements[1] = currentValue = 1.0;
		startTime = endTime = durationTime = 0;
	}
	
	// method to generate a fibonacci sequence by multiple algorithms
	public void generateSequence()
	{
		switch (sequenceBy)
		{
			case ITERATION:
				startTime = System.nanoTime();
				iterationGenerator();
				endTime = System.nanoTime();
				durationTime = (endTime - startTime);
				break;
			case RECURSIVE:
				startTime = System.nanoTime();
				recursiveGenerator(2);
				endTime = System.nanoTime();
				durationTime = (endTime - startTime);
				break;
			case ITERATION_OPT:
				startTime = System.nanoTime();
				optimizedIterationGenerator();
				endTime = System.nanoTime();
				durationTime = (endTime - startTime);
				break;
			case RECURSIVE_OPT:
				startTime = System.nanoTime();
				optimizedRecursiveGenerator(2);
				endTime = System.nanoTime();
				durationTime = (endTime - startTime);
				break;
			default:
				System.out.println("Problem with generating the sequence!");
		}
	}
	
	// method to generate the fibonacci sequence using the iteration solution
	private void iterationGenerator()
	{
		for (int i = 2; i < sizeOfSequence; i++)
		{
			fibElements[i] =  previousValue + currentValue;
			previousValue = currentValue;
			currentValue = fibElements[i];
		}
	}
	
	private void optimizedIterationGenerator()
	{
		for (int i = 2; i < sizeOfSequence; i++)
			fibElements[i] = fibElements[i - 1] + fibElements[i - 2];
	}
	
	// method to generate the fibonacci sequence using the recursion solution
	private void recursiveGenerator(int index)
	{
		if (recursiveCounter > 2)
		{
			fibElements[index] = previousValue + currentValue;
			previousValue = currentValue;
			currentValue = fibElements[index];
			recursiveCounter--;
			recursiveGenerator(++index);
		}
	}

	private void optimizedRecursiveGenerator(int index)
	{
		if (recursiveCounter > 2)
		{
			fibElements[index] = fibElements[index - 1] + fibElements[index - 2];
			recursiveCounter--;
			optimizedRecursiveGenerator(++index);
		}
	}
	
	@Override
	public String toString()
	{
		return durationTime + " nanoseconds\n" + "Depth of Iterations: " + 
			   sizeOfSequence + "\n" + 
			   "Sequence generated by: " + sequenceBy + 
			   "\nFibonacci Sequence = " + Arrays.toString(fibElements) + "\n";
	}
}
